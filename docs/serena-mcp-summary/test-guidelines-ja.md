# テストコード作成ガイドライン (Vitest / プロジェクト標準)

このドキュメントは、`src/lib/string-to-color-with-frame.test.ts` のテスト実装をプロジェクトの標準例として抽出し、
同様の品質・可読性でユニットテストを書くための実践的ガイドラインを日本語でまとめたものです。

## 目的

- テストの可読性と一貫性を保つ
- 異常系（エラー／境界値）と代表的な正常系をバランスよくカバーする
- プロジェクト内の他の開発者が読みやすく、追試できるテストを書く

## 前提

- テストランナー: Vitest
- 期待されるテストファイル配置: 元のソースファイルと同じ階層に `__tests__` ディレクトリを作成し、その中に `*.test.ts` を配置することをデフォルトとします（例: src/components/Button.tsx のテストは `src/components/__tests__/Button.test.ts` など）。既存プロジェクトや慣例に応じて例外を認めますが、新規作成時はこちらを推奨してください。
- インポートスタイル: 相対パスで対象モジュールをインポート

## テストの実行

- テストを実際に実行して動作を確認する場合（作成中の単発実行）は `pnpm test:run` を使用してください。CI やローカルでの単発実行に適しています。
- 開発中にウォッチで繰り返し実行したい場合は `pnpm test`（watch モード）を利用できます。

## ファイルの基本構成

- `describe` ブロックで対象モジュール／関数名をまとめる  
  例: `describe('stringToColorWithFrame', () => { ... })`
- `it` ブロックには日本語で何を検証するかを明確に書く（短く具体的に）  
  例: `it('文字列から正しい形式のカラーとフレームを返す', () => { ... })`

## 命名とコメント

- テスト名は「何を期待しているか」を表現する短い日本語文にする。
- テスト内のコメントも日本語で記述する（理由や前提を簡潔に残す）。
- 複雑な前提がある場合、テスト内の適切な箇所に短いコメントで理由を残す。

## 検証ポリシー（アサーション設計）

- まず「基本的な戻り値の形」を確認する（型・形式チェック）  
  例: 色は `#rrggbb` の形式であると期待する → `expect(color).toMatch(/^#[0-9a-f]{6}$/i)`
- 次に「振る舞いの安定性」を確認する（同じ入力で同じ出力など）  
  例: `expect(a).toEqual(b)` のような厳密比較を用いる
- 異なる入力では通常異なる（ただし完全衝突回避は保証されない）といった統計的/実用的な検証は、テスト名で注意を促す
- 境界・例外ケースを明確に作る  
  例: 空文字、長い文字列、Unicode（日本語／絵文字）、制御文字、null/undefined

## 異常系の取り扱い

- 型として不正な入力を与える場合は、実行時にどう振る舞うかを明示的に検証する（例: `Reflect.apply` を使って any 経由で呼ぶ）
- 例外を期待する場合は `expect(() => fn()).toThrow()` を使うか、`try/catch` で検証する

## テストの粒度と隔離

- 1 `it` ブロックは「1つの事実」を検証する（複数の関連アサーションは OK）。
- 外部副作用や時間に依存する振る舞いはモックするか、固定値にしてテストを安定化させる。

## 可読性のためのスタイル

- 日本語コメントとテスト名を用いる（このリポジトリの慣例に準拠）
- テスト内のコメントは日本語で記述する（国語化すると読みやすさと一貫性が向上する）
- 余計な `console.log` を残さない
- `catch` の例外変数を未使用にしない（ESLint 対策）。単に `catch { ... }` の形でも可

## 実例パターン（テンプレート）

```ts
import { describe, it, expect } from 'vitest'
import { foo } from './foo'

describe('foo', () => {
  it('基本ケース: 期待する型・形式を返す', () => {
    const out = foo('input')
    expect(out).toBe(/* 期待値 */)
  })

  it('同じ入力なら同じ出力を返す', () => {
    expect(foo('x')).toEqual(foo('x'))
  })

  it('異常系: 無効な入力で例外を投げる', () => {
    expect(() => foo(null as unknown as string)).toThrow()
  })
})
```

## ベストプラクティス（短めチェックリスト）

- [ ] 正常系の代表例を含めたテストがある
- [ ] 異常系（null, undefined, 型違い, 境界）を少なくとも1つ含める
- [ ] 依存がある外部 API はモックしている（必要な場合）
- [ ] テスト名/コメントは日本語で具体的に
- [ ] ESLint / TypeScript の警告を残さない

## FAQ / よくある注意点

- Q: 日付やタイムゾーンに依存するテストはどうする？  
  A: 固定日時を使う、タイムゾーンを明示的に指定する、または date-fns のような日時ライブラリを利用して明確に期待値を計算する。

- Q: ランダム値を使うロジックはどうテストする？  
  A: シード固定の乱数生成器を利用するか、ランダム生成部分を注入してテスト時に固定値を渡す。

## まとめ

`src/lib/string-to-color-with-frame.test.ts` は、単純で読みやすく、正常系・境界系をバランスよくカバーした良い例です。新しいテストを書くときはここを参照し、上記のチェックリストに従ってください。

---

（このファイルは `docs/serena-mcp-summary` に追加されました）
